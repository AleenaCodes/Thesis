% The document class supplies options to control rendering of some standard
% features in the result.  The goal is for uniform style, so some attention
% to detail is *vital* with all fields.  Each field (i.e., text inside the
% curly braces below, so the MEng text inside {MEng} for instance) should
% take into account the following:
%
% - author name       should be formatted as "FirstName LastName"
%   (not "Initial LastName" for example),
% - supervisor name   should be formatted as "Title FirstName LastName"
%   (where Title is "Dr." or "Prof." for example),
% - degree programme  should be "BSc", "MEng", "MSci", "MSc" or "PhD",
% - dissertation title should be correctly capitalised (plus you can have
%   an optional sub-title if appropriate, or leave this field blank),
% - dissertation type should be formatted as one of the following:
%   * for the MEng degree programme either "enterprise" or "research" to
%     reflect the stream,
%   * for the MSc  degree programme "$X/Y/Z$" for a project deemed to be
%     X%, Y% and Z% of type I, II and III.
% - year              should be formatted as a 4-digit year of submission
%   (so 2014 rather than the accademic year, say 2013/14 say).

\documentclass[ % the name of the author
                    author={Aleena Baig},
                % the name of the supervisor
                supervisor={Dr Simon Lock},
                % the degree programme
                    degree={BSc},
                % the dissertation    title (which cannot be blank)
                     title={On Making Web Accessible Graphs},
                % the dissertation subtitle (which can    be blank)
                  subtitle={},
                % the dissertation     type
                %  type={enterprise},
                % the year of submission
                      year={2019} ]{dissertation}

\usepackage[utf8]{inputenc}
\setcounter{tocdepth}{2}

\usepackage{glossaries}
\renewcommand{\glossarysection}[2][]{}

% \usepackage{geometry}
%  \geometry{
%  a4paper,
%  total={150mm,257mm},
%  left=30mm,
%  top=20mm,
%  }
 \renewcommand{\baselinestretch}{1.4}

\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\addbibresource{citations.bib}

\makeglossaries
\loadglsentries{defs}

\begin{document}

% =============================================================================

% This section simply introduces the structural guidelines.  It can clearly
% be deleted (or commented out) if you use the file as a template for your
% own dissertation: everything following it is in the correct order to use
% as is.

\iffalse
\section*{Prelude}
\thispagestyle{empty}

A typical dissertation will be structured according to (somewhat) standard
sections, described in what follows.  However, it is hard and perhaps even
counter-productive to generalise: the goal is {\em not} to be prescriptive,
but simply to act as a guideline.  In particular, each page count given is
important but {\em not} absolute: their aim is simply to highlight that a
clear, concise description is better than a rambling alternative that makes
it hard to separate important content and facts from trivia.

You can use this document as a \LaTeX-based~\cite{latexbook1,latexbook2}
template for your own dissertation by simply deleting extraneous sections
and content; keep in mind that the associated {\tt Makefile} could be of
use, in particular because it automatically executes \mbox{BibTeX} to
deal with the associated bibliography.

You can, on the other hand, opt {\em not} to use this template; this is a
perfectly acceptable approach.  Note that a standard cover and declaration
of authorship may still be produced online via
\[
\mbox{\url{http://www.cs.bris.ac.uk/Teaching/Resources/cover.html}}
\]

\fi
% =============================================================================

% This macro creates the standard UoB title page by using information drawn
% from the document class (meaning it is vital you select the correct degree
% title and so on).

\maketitle

% After the title page (which is a special case in that it is not numbered)
% comes the front matter or preliminaries; this macro signals the start of
% such content, meaning the pages are numbered with Roman numerals.

\frontmatter

% This macro creates the standard UoB declaration; on the printed hard-copy,
% this must be physically signed by the author in the space indicated.

\makedecl

\tableofcontents

% LaTeX automatically generates a table of contents, plus associated lists
% of figures, tables and algorithms.  The former is a compulsory part of the
% dissertation, but if you do not require the latter they can be suppressed
% by simply commenting out the associated macro.



\chapter{Abstract}

% TODO - write

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent id hendrerit libero. In in cursus leo, sit amet tristique risus. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Mauris nec arcu at elit tincidunt interdum sit amet at sem. Etiam ultrices, metus id pulvinar cursus, massa est fermentum nunc, vitae facilisis lectus turpis non dolor. Fusce a egestas lorem. In a orci vitae nunc pulvinar sodales ut nec odio. Nunc eu cursus orci, at tempus orci. Nullam consequat neque a hendrerit luctus. Etiam ut turpis augue. Nunc iaculis, tellus eget semper lobortis, sem velit euismod sapien, at lacinia ligula sem a urna.

\mainmatter

\chapter{Background}

\section{Introduction}
When HTML was first conceived in 1990, there were only 2.6 million users worldwide (in comparison to the several billion that there are now). \cite{ourworldindata:internet}. The simple markup language served the needs of the early web well - anyone could easily pick it up and translate a document into HTML, ready for it to be viewed in a browser.

Within a few years, it had already become clear that HTML was extremely limiting for developers, and innovation had to take place in order to keep it relevant - in 1993 the browser Mosaic was shipped with support for the \texttt{<img>} tag, and many more new tags followed in order to accommodate for the ever-growing content types. \cite{historyofhtml}

As time went on, both the number of the users on the web and the type of content being published changed drastically, and HTML went through a variety of iterations, eventually resulting on HTML5 which, combined with CSS4 and Javascript, forms the core of the internet,

However, as the number of users has grown, so have the amount of internet users with differing accessibility needs, including visual, motor and cognitive needs. As HTML has become more complex, so have the website layouts, due in no small part to the need for websites to work on a much larger variety of devices and screen sizes than before. Whereas the simplistic "document-style" websites of the early internet were easily accessible to most users, this is no longer the case.

% LATER Try to find stat of how many sites are not accessible

\section{Why is Accessibility Important?}

The idea of web accessibility can often not even cross the mind of a developer if they've never had to use assistive technologies, and for those who do consider it, it can often seem like a minor part of website design, as the perception is that a very small percentage of web users have accessibility needs.
However, the statistics paint a very different story - the World Health Organisation estimates that around 15\% of people worldwide live with some sort of a disability. \cite{WHOdisability}

Thus, it is clear the accessibility should be a strong consideration when developing websites, but there are some main barriers for developers when doing this

\begin{itemize}
    \item Lack of knowledge about web accessibility standards
    \item There are not many tools to test and fix accessibility issues
    \item User testing with differently-abled users can be expensive and time-consuming
    \item Some development tools (such as drag-and-drop) don't support accessibility
    \item Content may be provided by a 3rd party, so accessibility isn't guaranteed
\end{itemize}

\subsection{Use Cases}
%
Web accessibility encompasses a lot of different use cases, including
%
\begin{itemize}
    \item Visual - blind or partially-blind users, who may use a screen-reader or require larger text; colour-blind users
    \item Auditory - deaf or partially-deaf users, who may rely on captions for all audio or audio with a lot of background noise
    \item Cognitive and Neurological - users who may need simpler language to be used, such as those with learning disabilities, or non-native speakers of a language. This also includes people with neurological disorders such as ADHD who need content that is easy to process on a short attention-span
    \item Physical - people with disabilities that affect them physical such as for hand movement. There are many different mice and keyboard types to help with this, and custom technologies such as foot pumps and sip-and-puff machines
    \item Speech - People who are unable to speak clearly or at all, they may struggle with voice commands so interfaces should not be voice control-only
\end{itemize}
% LATER add more detail here?
% LATER Add pictures?
% w3 site on "diverse abilities" will give info for here
% LATER number of users
% LATER - accessibility needs
%
However there are also lots of other cases to consider \cite{WAIaccessibilityintro}
%
\begin{itemize}
    \item "Temporary disabilities" - for example a broken arm, operating single-handed (such as holding a baby in one arm), lost glasses, RSI
    \item People using devices in different input modes such as on a TV screen
    \item "Situational limits" - seeing a screen in bright sunlight, or not being able to hear audio in a loud environment
    \item Older people with changing abilities
    \item People with slower or limited internet access
\end{itemize}
%
Through this we can see that web accessibility support the including or people with disabilities, older people, people in rural areas and people in developing countries
%
\subsection{The Business Case for Accessibility}

With so many disabled users worldwide, disregarding the need for a site to be accessible to such a large group of users does not make sense from a business standpoint, and will result in a larger overall possible market.

Increasing site accessibility often involves structuring and labelling things better, and so can result in much better SEO for a site. It also means that the site will be easier to view on multiple devices, and there will be reduced maintenance cost over time.\cite{WAIaccessibilityintro}

Focusing on site accessibility not only demonstrates corporate social responsibility, but in many parts of the world certain sites (such as government services) are required by law. This includes the Equality Act of 2010 \cite{eqa2010} in the UK and Section 508 \cite{section508} in the USA. Access to information and communications technologies, including the web, is also defined as a basic human right in the United Nations Convention on the Rights of Persons with Disabilities (UN CRPD). \cite{accessibilityUN}

\section{The Current State of Web Accessibility}

When the internet began, the idea of accessibility was at its core -

\begin{quote}
\centering
"The power of the Web is in its universality. Access by everyone regardless of disability is an essential aspect."

- Tim Berners-Lee, W3C Director and inventor of the World Wide Web
\end{quote}
%
And this idea is still followed in recent iterations of HTML. Pure HTML webpages were accessible out-of-the-box when HTML was first made, and this continues to be the case today - sites made in basic HTML5 are still largely accessible. However the current web is not pure HTML - CSS that originally changed superficial styling is now also commonly-used for layout and interaction, and Javascript has become the de facto language of the internet, with many new frameworks being made often and used by popular sites such as Facebook and Netflix.

Whereas web pages used to be static and have a linear layout, they are now much more dynamic with changing content (such as social media platforms with a livestream) and can be displayed in a variety of different layouts depending on device and screen size. While this satisfies consumers needs to access current information on a variety of devices, it has resulted in a decrease in accessibility for some users. Changing layouts can mean that a screen-reader reads out information in a completely different order than it is displayed visually, and moving interfaces can become overloaded and confusing for users with cognitive and physical disabilities.

\subsection{The Changing Web}

A key idea that has been on the rise in the last few years, has been component-based design. With HTML5 having a finite (and mainly quite simple) type of element, web development has moved towards generating custom HTML elements which can provide new and novel types of interactivity on web pages.

While this has allowed for more re-usability in web development by allowing encapsulation, websites that are heavily component-based can have greatly decreased accessibility if components are not built with accessibility in mind.

Responsive layouts are a necessity in a world where the internet is accessed on mobile as often as desktop (if not more) \cite{mobileusestudy}. With websites needing to support both desktop and mobile users with one site, there is more re-ordering and hiding of page contents than before, which won't have an impact on sighted users but can result in screen-readers providing an un-ordered view of the contents of a web page or missing out important information.

Many are turning towards frameworks to provide out-of-the-box responsiveness rather than manually providing different layouts for each screen size, and these can be a good solution. For example Bootstrap provides a framework for responsive sites that can be used to make accessible websites, but it is down to the developer to ensure WCAG compliancy, as there are many aspects that shouldn't be used, such as default button colours and carousels \cite{bootstrapaccessibility}. Others, such as Turret, allow for things like screen-reader only content to be defined \cite{turretaccessibility}.

Recent years have also seen Flexbox and CSS Grid being used for arranging elements on a page. These decouple the source order (i.e. the order of the elements declared in HTML) and their visual order on the screen. This is another thing that has little repercussions on average web users, but can mean that keyboard or screen-reader users are unable to access content in the right order.

% LATER provide pic of unordered page

With web development, there are many parts involved in the making and viewing of sites \cite{w3components} - developers use authoring and evaluation tools to make content, and then users use browsers, and optionally assistive technologies, to interact with the content. For an accessibility feature to become widely-used, it is crucial for it to be implemented in many or all of these parts - developers will have less motivation to use a feature if it is not implemented consistently across browsers, or hard to do in a language.

% LATER provide pic of process

\subsection{Web Accessibility Guidelines}
With the growing complexity of websites, and more web developers than ever, the World Wide Web Consortium (W3C) publish some guidelines and specifications around building accessibility into web pages.
These provide some guidelines in terms of the semantics to use, and how to define interactions, but even by following all of these there is still always a need to test on real users to ensure a website really is accessible to a range of people.

\subsubsection{WCAG}

The Web Content Accessibility Guidelines (WCAG) \cite{WCAG} are part of a series of web accessibility guidelines published by the Web Accessibility Initiative (WAI) of the World Wide Web Consortium (W3C). WCAG 2.1 was published in 2018, and provides a much-needed update to the previous version published a decade earlier - mobile phone web browsing especially has increased a lot in the last 10 years and requires a new set of accessibility guidelines.

The WCAG are organised under 4 principles

\begin{itemize}
    \item Perceivable - users must be able to perceive the information being presented (it can't be invisible to all of their senses)
    \item Operable - users must be able to operate the interface (all interactions be able to be performed by the user)
    \item Understandable - users must be able to understand the information presented and how to operate the interface
    \item Robust - users must be able to access the content from a variety of user agents, including current assistive technologies
\end{itemize}
%
Each of these principles has a set of testable criteria, and these can be met at 3 levels - A, AA and AAA.

\subsubsection{WAI-ARIA}

The WAI-ARIA \cite{WAIARIA} is a technical specification for making web pages accessible. WAI-ARIA defines some extra attributes \cite{WAIARIAspec}

\begin{itemize}
    \item Roles - these define common structural roles on a web page such as \texttt{button}, \texttt{navigation}, \texttt{banner} and \texttt{tabgroup}, with a lot of overlap with HTML5 semantic elements
    \item Properties - these define the properties of elements that are important for meaning or semantics, such as \texttt{aria-required} to indicate if a form input is compulsory, or \texttt{aria-modal} to indicate that an element is modal when displayed
    \item States - these define a specific property type which indicate the current state of an element (these can be changed over time as opposed to properties), such as \texttt{aria-disabled} to indicate that a form input is visible but not editable
\end{itemize}

\subsection{Current Tooling}

\subsubsection{Tools for Development}

When aiming to develop an accessible website, there is no easy route - instead, it is important to keep accessibility in mind throughout the design and development process. The WCAG should be consulted when designing the site, and WAI-ARIA for guidelines on the semantics to use when developing the site.

As HTML5 is designed to be accessible, it is key to try and keep things as simple as possible, and not try to do "hacky" things when developing a site, such as using CSS to change the ordering of how elements show on a page. It is also important to use the designated HTML elements for each component on a page, such as using a \texttt{<button>} tag for a button instead of adding a \texttt{<span>} and styling it into a button.

Many web frameworks are built with accessibility considered, and so using something like Bootstrap, Turret, Foundation or Vanilla for building the site and then evaluating and fixing any accessibility issues can also be a good idea.

A useful Javascript library that is available is Ally.js \cite{allyjs}, which can be loaded into a JS project and provides a set of modules to help simplify accessibility challenges, such as setting specific ordering for tab focuses.

There are many tools that can also be used to evaluate a site's accessibility or even give live feedback to the developer while they are coding, these are discussed below.

\subsubsection{Tools for Evaluation}

Several well-made tools are available freely online to test and fix accessibility issues. Pa11y \cite{pa11y} provides a suite of tools to flag up accessibility issues, including tools that can be integrated into a CI workflow and provide live feedback on issues. HTML\_CodeSniffer \cite{codesniffer} is a linter that allows different standards, such as WCAG, to be checked against code. WAVE \cite{wave} is another web accessibility evaluation tool that simply takes a URL and evaluates missing accessibility features.

It can be useful during development for a developer to simulate different disabilities to test the sight, as this can flag up larger issues before testing on people who use assistive technologies. Testing with a screen-reader is a good way to understand how a site will sound , JAWS and NVDA are two of the most commonly-used screen-readers. Most platforms also have native screen-readers that can be tested with - Voiceover for Mac and iOS, Narrator for Windows, TalkBack for Android.

It can also be useful to check how a sight looks for Some tools for this include Check My Colours \cite{colourchecker} to check colour contrast, and Color Oracle \cite{colororacle} to simulate colour blindness.

A recent project from IBM is the Va11ys project \cite{va11ys}, which provides a range of code samples that allow a developer to test out different assistive technologies. These provide a good idea of how different accessible features should look in code and how they should be interpreted by different assistive technologies.

Overall, we can see that there is a wide range of tools that are designed to help developers evaluate accessibility on their site and recognise issues before testing with real users.

%LATER- add some pics of the evaluating tools

\subsubsection{Tools for Viewing Sites}

Users with disabilities tend to have two different approaches to interactions with the web

\begin{itemize}
    \item Assistive Technologies - using tools like screen-readers and voice recognition software to turn parts or all of websites into an understandable format
    \item Adaptive Strategies - making small changes to a site's format to make it easier to process, such as making fonts larger or turning captions on for videos
\end{itemize}

With each of these approaches, they require the developer to give correct layout/prompts on the site for them to work - the tables below detail this

\paragraph{Assistive Technologies}

\begin{center}
\begin{tabular}{|p{3cm}|p{5cm}|p{5cm}|}
 \hline
 Technology & Usage & Developer Notes \\ [0.5ex]
 \hline \hline
 Screen-Reader & Processes content on desktops and browsers, and converts it to audio or braille & Content needs to be structured properly and include labels and descriptions where needed, semantic HTML should be used as far as possible \\
 \hline
 Pop-up/Animation Blocker & Stops automatic pop-ups and redirection & Important info should not be included in pop-ups, and site browsing flow should not include redirection \\
 \hline
 Reading Assistant & Software that changes content presentation to make it more readable - this can include changing font and space, hiding parts of the page and reading text aloud & Different sections on a page should be used and labelled correctly, layouts should be responsive to font changes \\
 \hline
 Keyboard/Mechanical Inputs & Many different custom keyboards are available - those with larger or illuminated keys, on-screen keyboard, sip-and-puff switches  & Content should be able to all be accessed via keyboard, and grouped together to allow fast navigation through a page \\
 \hline
 Mouse & Many different mice are available - touchpads, trackballs, joysticks & Different sections should be labelled, and clickable areas should be large enough to accommodate error margins\\
 \hline
 Eye Tracking & Monitors eye movements to control the mouse pointer, and blinking to click the mouse & Clickable areas on the page should not be too small \\
 \hline
 Voice Tracking & Uses voice commands to dictate text and issue commands & Different sections and clickable areas should be labelled well \\ [1ex]
 \hline
\end{tabular}
\end{center}

% Left off - voice browser, braille display

\paragraph{Adaptive Strategies}

\begin{center}
\begin{tabular}{|p{3cm}|p{5cm}|p{5cm}|}
 \hline
 Technology & Usage & Developer Notes \\ [0.5ex]
 \hline \hline
 Captions & Text with verbatim recording of any speech or audio & Video platforms should be built to allow simultaneous captioning files to be run alongside video files \\
 \hline
 Screen Magnifier/Bigger Fonts & Pages can be magnified either be magnifying small sections or increasing font sizes overall & Page layouts should support text changes by using relative units for measurements and allow re-flow of text \\
 \hline
 Higher Contrast & Colours with significant contrast are easier to view for less-sighted and colour-blind users & Colour palettes should be decided in advance and tested via WCAG guidelines \\
 \hline
 Volume Control & Audio may need to be volume-adjusted or turned off altogether & Audio should not autoplay in order to not interfere with audio technologies, and options to adjust volume (including to 0) should be visible and accessible to both mouse and keyboard technologies \\ [1ex]
 \hline
\end{tabular}
\end{center}

% LATER - write more?

\subsubsection{Accessibility APIs}

In the early 1990's, assistive technologies would read what was on the screen and try to guess the functions of different elements and their states, e.g. by looking at class names of objects and seeing if they were highlighted. However, this was not always accurate and there was often some delay time between new features being introduced and assistive technologies being developed to recognise them. \cite{smashingAPIs}

In the late 1990's, accessibility APIs were introduced as an alternative that provided a more reliable way to pass information to assistive technologies. For the first time, developers had the ability to provide information to assistive technologies in a consistent way.

Although this was a step up from the previous way of simply guessing information about pages, many early accessibility APIs still did not provide much structural information for the page, making it hard to understand how objects related to each other. New APIs were developed over the next decade, which were then able to provide information on page structure and rich text formatting.

Accessibility APIs represent objects in a UI, with each object able to be queried for information, including its role, name and current state. UI's are represented as a hierarchical tree, and many different elements are now able to be recognised, such as tabular layouts, and event notifications.

There are accessibility APIs on all major operating systems (both desktop and mobile), and browsers typically support the accessibility API for the platform they're running on, passing information about the browser and the rendered content onto the API.

One of the problems developers face is not being able to add to accessibility APIs, they can only write in semantics that will work well with an API but not directly influence the accessibility tree that an assistive technology will form.

A new (and still experimental) technology currently being worked on is the Accessibility Object Model (AOM). This aims to allow developers to directly provide information to assistive technology APIs via adding custom fields to elements on a page.

% LATER - add more to AOM bit?

\section{Accessible Visuals}

Visuals are often used to quickly and easily convey large amounts of information to a reader. Data in tabular form can be hard to dig through, and graphs allow viewers to spot both simple and complex trends across many fields in one go, and also draw their own conclusions about the data without having to see a large amount of raw data.

% LATER say something more about visuals

\subsection{Challenge with Creating Accessible Visuals}

Making pictures and graphs accessible on the web is often done by adding alt-text attributes to detail what an image shows. But it is easy to see why it would be hard to encompass the same level of detail in words for a graph than a viewer would be able to get visually

\begin{itemize}
    \item "Graph showing stock price over time" - does not convey any actual information about the data in the graph
    \item "Graph showing upward trend of stock price" - conveys a bit more information about the data, but does not allow the user to get any sense of prices
    \item "Graph showing upward trend of stock price from $\pounds$ 60 to $\pounds$ 180 over 2 years" - gives some idea of prices and how fast they climbed but does not allow the user to see smaller details such as any dips in price
\end{itemize}
%
It is clear that in order for a text-based web user to have anywhere close to the insight that a sighted user would have from a graph, a large amount of long-winded description would need to be included with any graphs, which can be hard and long for a developer to write. Many developers try to account for this by also including the data in tabular form, which screen-readers can access and read. However, this is a clunky solution, especially as if the data was displayed graphically in the first place, it was likely not very easily consumable in tabular form.

\subsection{Current Solutions}

There are many JavaScript graphing libraries available for the web, most notably libraries such as Chart.js, D3.js, Highcharts and Google Charts.

Most of these libraries have some accessibility in mind in terms of alt-text and navigating via keyboard, but a big problem is consistency among browsers. Libraries like D3 and AmCharts use SVG to form the images, and the \texttt{tabindex} property (specifying order for the TAB key to move through shapes) is not implemented in all main browsers yet.

The Highcharts library offers some accessibility in terms of a custom module that can be loaded in. This provides the ability to show screen-reader users the data in raw form, and to use high-contrast patterns in the graph. However, this still relies on the user to add sufficient alt-text to the graph, and requires some custom set up from the user in terms of turning on a lot of different settings to enable keyboard navigation and other accessibility features.

% LATER - write more
% Highcharts
% Amcharts
% Kendo UI
% Evocharts

\subsection{Aim}

In this paper, I will explore the creation of a fully-functioning Javascript graphing library that comes with accessibility out-of-the-box.

This library will provide key accessibility features for several different types of graphs, with minimal work from the developer. In order to focus on accessibility and functionality, this library will be limited to a few common types of graphs.

% LATER - write more
% Idea - make graphs accessible - tool for developers - make it easier for developers to be accessible then more will do it
% Possible solutions - framework, linter-type thing to add to components
% "in this paper we will explore the creation of a fully functioning javascript library that will allow developers to generate fully accessible graphics (to ARIA standards) with minimal work"
% "we will also explore some other possible solutions, including the currently experimental AOM"

\subsection{Technical Challenges}

One of the main technical challenges is making a solution that creates graphs that are usable for people browsing with and without assistive technologies.

It is also key to note that while the WCAG provides some clear guidelines on making content accessible, it is still hard to get every use case due to the diverse needs of people using the internet.

When trying to provide all the information that sighted users would see via audio, it will also be important to keep a balance between providing relevant information and overloading the user.

From a usability standpoint, it will also need to be easy for developers to use, but still be able to be customised enough that developers can create custom graphics to their liking, while maintaining the same level of accessibility.

% LATER - write more
% Technical - making a solution that works for both accessible and normal users out of the box
% Accessibility challenges - hard to truly get every use case, the W3C guidelines are many research - will use those as a good indicator
% Need the balance between providing relevant info and overloading the user (as per cognitive guideline)
% Need it to be plug-and-play for developers - as easy as other libraries

\section{Related Work}

% {TODO}

% LATER - write
% Some papers
% Some books

\chapter{Design}

\section{Basics}

When thinking about the implementation, there were 3 main areas to think about

\begin{itemize}
    \item Types of graphs
    \item Information to present
    \item Colours and patterns
\end{itemize}

\subsection{Types of Graphs}

As I was trying to build a proof of concept, as opposed to a comprehensive library, I decided to focus on 3 different graph types - bar graphs, line graphs and pie charts. These chart types are some of the more commonly-used ones, and are different enough to provide a varied proof of concept.

% TODO Pics of three types (use ones from poster)

\subsection{Information to Present}

Having spoken to some people who use screen-readers daily and observed them using these to browse webpages, it was clear that screen-reader users don't tend to listen to a web pages in its entirety, instead scrolling through quickly to find information that they need.

In order to accommodate this, I aimed to create labels for the chart that weren't too verbose, and which had the most pertinent information at the start of the label. This would mean that if the user was trying to find a particular data point, they would be able to move through each data point quickly in order to accomplish this.

I felt that the key information to present were the headings and values of the data, and also to highlight some broader trends without overloading the user with too much detail.

% TODO some pics from poster showing read-outs
    
\subsection{Colours and Patterns}

Use of colour and pattern is important for users who are partially-sighted of colour-blind, and a common method found in many websites and games that rely on colour, is to have a "colour-blind" mode which changes different colours to be different patterns instead.

The WCAG require a minimum level of contrast of \textit{4.5:1} between colours to fulfil criterion \textit{1.4.3 - Minimum Contrast}, and so I used this as a guideline to select colours.

I also aimed to combine the user of contrasting colours with different patterns as well, as these would help users distinguish between different sections. Another thing that is known to be helpful with partially-sighted and colour-blind users it to allow some white space between corresponding elements to help the user better distinguish between elements such as bars or segments on charts.

When building a colour palette, I aimed to have 6 different colours in my colour palette, which would have a good amount of contrast with each other. Since I was making a graphing library, I initially thought of using a \textit{Brewer Palette} - color combinations that are specifically selected for their properties for use in data visualisation and information design. These colours are selected based on human perception around which colours seem associated with each and which do not, and so a \textit{Qualitative Brewer Palette} seemed like a good choice for the graphs I was creating. However I found that these colours had little contrast between them by WCAG standards, and so would not be suitable for my use.

In order to check contrast between each colour, I used a colour contrast-checker from the design agency \textit{EightShapes} to load in multiple colours and see the contrast level between each colour.

% TODO - picture of colour checking

With this I was able to build a palette of 6 colours which had a fairly high contrast level between most of the other colours (i.e. 3 or more). However, it proved very hard to find colours that had a high enough contrast between all other colours in a palette, and so I decided to keep the current palette and simply make sure that neighbouring colours were high contrast.

\section{Accessibility Tree}

When looking at web accessibility, a key concept is the accessibility tree - a tree structure created from a web page's DOM, which assistive technologies are then able to interact with. One of the major technical issues with this project was that, different web browsers may generate slightly different accessibility trees from the same HTML code and different assistive technologies may also interpret the same accessibility tree differently. Thus it would be hard to make a solution that worked across all of the common assistive technology/browser/operating system combinations.

% TODO - is the bit about accessibility trees correct? (could also do with a reword of the second sentence)
% TODO - diagram of how assistive tech uses accessibility trees?

Many browsers, such as Mozilla Firefox, provide tools to directly view the accessibility tree, and so I aimed to use syntax to create as clean an accessibility tree as possible (and by extension the DOM would also be clean).

The WAI-ARIA standards provide a set of roles, states and properties that can be given to HTML elements, along with a way to label these, and so I aimed to use these extensively to build an accessibility tree with correct elements and labels

\section{Library Design}

When building the Javascript library, since this was a proof-of-concept, I aimed for create a fairly simple API for the developer, in which the page \texttt{div} in which to create the chart, the chart type, and data source (a local file) could be specified. Along with this, the chart title and units of data would need to be specified, in order to generate the metadata for the chart correctly.

\chapter{Implementation}

\section{Implementation of syntax}

\subsection{Using SVG}

The most common way of generating images in webpages is using SVG, either embedded (included from an external file) or inline. SVG allows geometric shapes to be specified and positioned, and so it was an obvious choice for this project.

Inlining SVG provides more predictable results and better control over properties than adding in SVG files with a \texttt{<img>} or \texttt{<use>} tag. This is because the SVG source is then directly available in the DOM, which is exposed by the accessibility API used by assistive technologies.

While SVG has been around for a while (since XXX), there has recently been a push towards a more modern version, resulting in a new specification for SVG 2 being released in XXX.

One of the new features in this specification is the abilities to add \texttt{tabindex} to SVG elements (such as shapes or text). This is useful, as previously the only way to make elements in an SVG that were focusable by keyboard, was by including a HTML element that supported this, such as the \texttt{<a>} tag.

Although the W3C has release this specification, the onus is on the makers of a browser to implement these new features in their browser. Thus far there has been little uptake on this, with most browsers only implementing part of the specification, including accessibility-forward browsers such as Mozilla Firefox. Hence it is not necessarily an easy task to make a solution that works consistently across multiple web browsers (a problem common in all branches of web development).

% TODO - find when SVG was made, and when SVG 2 was made.

\subsection{HTML Layout}

HTML, by virtue of being a markup language that defines only the structure of a webpage, is set up to generate a DOM that is true to the page's visual structure, and as web development has progressed, new elements have been added to account for commonly-used parts of a webpage.

HTML5 introduced the concept of a webpage having "sections", with a new \texttt{<section>} tag that could be used to define a page's sections, as opposed to the more ambiguous \texttt{<div>}.

Sections are able to be nested within each other, giving the same type of structure as the original \texttt{<h1>, <h2>, <h3>} etc. tags created. However it is not always desirable to have every section's children included in the outline of it's parent.

A sectioning root is an HTML element that can have its own outline, but the sections and headings inside it do not contribute to the outline of its ancestor. The sectioning root \texttt{<figure>} is the key one that I used in my development, to create an element that was able to have many children (i.e. axis, data points etc.) and not create a lot of excess outline in the DOM for the parent section.

% picture illustrating sectioning root and non-sectioning root?

\subsection{ARIA syntax}

As discussed before, I aimed to create as much of the accessibility tree as possible from using inbuilt HTML properties (e.g. using \texttt{<h1>}) for headers as opposed to adding an ARIA role to achieve this. ARIA provides custom roles for elements, but many of these double up with those assigned to native HTML elements (such as \texttt{role="button"}, which can also be assigned by using \texttt{<button>}).

% TODO - check that the button example makes sense

While I was initially using the element \texttt{<figure>} as the parent element, I found that it was easier to use the ARIA role \texttt{figure} directly as an attribute of the \texttt{<svg>} tag, thus making it act as a \texttt{<figure>} tag when it came to creating the DOM, and also meaning that it showed up directly as \texttt{figure} in the accessibility tree, as opposed to being an only-child \texttt{svg} nested inside a \texttt{figure}.

I used the SVG properties \texttt{title} and \texttt{desc} to create a title and description for the chart. A lot of browsers were able to use only this to correctly label the figure in the accessibility tree, but I also encoded this in using ARIA.

The ARIA property \texttt{aria-labelledby} is used to create a label that is displayed in the accessibility tree only, thus making it only visible to people using assistive technologies, and not available to those browsing the web normally.

The \texttt{aria-labelledby} property, alongside the \texttt{aria-describedby} property identify the element(s) are used to label and describe the current element (\texttt{describedby} is intended for a more verbose description).

In my case, I found that \texttt{aria-describedby} did not work very consistently across browsers, and so was largely pointless in most use cases. Instead, I doubled on \texttt{aria-labelledby} to include both the title and description.

Through using both the \texttt{<title>} and \texttt{desc} for the SVG, and using \texttt{aria-labelledby} to also link these, I covered most browser/screen-reader combinations for reading this out.

Since the reader was going to browse through the contents of the SVG, I also used \texttt{aria-hidden} to hide the excess parts of the chart, such as the lines and labelling for each axis. This was an effective way to keep these out of the accessibility but keep them in the DOM, so visible on the page.

% TODO - image of side-by-side accessibility tree and HTML to show how <title> and <desc> were encoded, and how aria-hidden would show up

In order to make the each data point able to be accessed individually, I added a \texttt{tabindex=0} property to each data point. This made each of these elements focusable and thus added them to the order in sequential keyboard navigation, letting them be accessed by using the \textit{Tab} key on a keyboard.

I also grouped the data points in an SVG group \texttt{<g>} and gave this an ARIA role of \texttt{list}, along with a \texttt{<title>}. This meant that when a screen-reader came across the list it would read out the title. I then added each data point as an SVG group of its own, with an ARIA role of \texttt{listitem}, and a \texttt{<title>}, which the screen-reader would read out on focussing on each list item. Setting up the chart as a \texttt{list} containing a set of \texttt{listitem} also meant that users of technologies that have other shortcuts for navigating lists could also use these.

% TODO - diagram of list and listitem

\subsection{WCAG}

I also had the Web Content Accessibility Guidelines (WCAG) in mind when implementing this, and so I had to implement a few things to satisfy the guidelines, most notably a \textit{Bypass Block} mechanism as specified in success criterion \textit{2.4.1}. This meant adding a simple link that let the user skip past the graph entirely if they chose to, as opposed to having to listen to the entire read-out of the graph.

Although many of the criteria didn't apply to this project, especially those to do with an entire webpage, or time-based events, some of the other criteria also had to be implemented in terms of syntax, such as

\begin{itemize}
    \item \textit{Criterion 1.1.1} - Providing non-text Content - this was a major focus of my implementation, and done using \texttt{aria-labelledby} and \texttt{aria-label}
    \item \textit{Criterion 1.3.1} - Info and Relationships - by creating the data points as a \texttt{list} with corresponding \texttt{listitem} elements, the nature of the relationship of these was kept clear
    \item \textit{Criterion 2.1.3} - Keyboard - by making elements focusable (via adding \texttt{tabindex=0}) all the content was operable through keyboard interface
    \item \textit{Criterion 2.5.3} - Label in Name - all the generated \texttt{aria-label} labellings matched the visual information that was displayed on screen
    \item \textit{Criterion 3.1.5} - Reading Level - the \texttt{aria-label} on each data point was kept short and simple in order to make it clearly understandable by users of all reading levels
    \item \textit{Criterion 4.1.2} - Name, Role, Value - all roles were set using the standard \texttt{role=} syntax or auto-generated from the user of HTML tags, so any external technologies (such as assistive technologies) would be able to extract this information
\end{itemize}

\subsection{Expanding for compatibility in Safari/MacOS}

When testing on Windows machines with the two most popular screen-readers - \textit{NVDA} and \textit{JAWS}, the system of having a \texttt{<title>} tag for each \texttt{listitem} meant that when the user focussed on each element the specified \texttt{title} was read out.

However on MacOS with the native screen-reader \textit{Voiceover} this did not work at all, with no label being read out. This was a good example of large inconsistencies between browsers, even amongst the more well-maintained browsers.

In order to have the graph function as normal, I had to add an extra layer of labelling that \textit{Voiceover} would pick up on. For this I used the \texttt{aria-label} attribute to label each data point, with the same info as specified in the \texttt{<title>} tag. The \texttt{aria-label} attribute is similar to \texttt{aria-labelledby} but uses a direct string to read out, as opposed to referencing another HTML element as a label. It was suitable for use here as the label was fairly short, but would not have been suitable for a longform description to be included.

\section{Implementation of library}

\subsection{Basic Structure}

I initially began with a hard-coded HTML prototype to figure out syntax and run some user testing with. Once I had decided on the HTML syntax that I would use, I then proceeded to package this into a Javascript library which would be able to produce the same graphs with any provided dataset.

I was keen to not have any external dependencies for the library, as Javascript libraries are well-known for quickly growing very large as multiple levels of dependencies are loaded for a single small function. Thus I wrote only in "Vanilla" Javascript - plain javascript without any functions from third-party libraries.

While a Javascript library can just be included as a single file with all functions in it, with each required function just called directly, in order to avoid nameclashes with other libaries, I put the required function into a global object, which then served as the unique namespace for the library.
\newline
\begin{lstlisting}
var accessibleGrapher = {
    makeAccessibleChart: function(selector, chartInfo) {

    ...
  }
}
\end{lstlisting}

\subsection{Pulling in Data}

As the library was intended for small amounts of data, it would have been possible to simply require the user to send an array of data in the function call. However the convention in graphing libraries is to allow an external file to be handed in, either locally or via an API call.

Since I was building a proof-of-concept library, I opted to only provide the option for loading in a local JSON file, although extending the library to load a file via an API call would not require too much extra code in the library.

The file was loaded in via an \texttt{XMLHttpRequest} - a standard object provided by the browser's Javascript environment that allows data transfer between a web browser and web server.

% TODO - diagram of xmlhttp request, like at https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest

I wrote a small function that would take the file path for the data that was provided by the developer, and run a callback to find and load in the file, and then create the graph.

\begin{lstlisting}
function loadJSONandMakeChart(fileName, callback) {
  var reqObj = new XMLHttpRequest();
  reqObj.overrideMimeType("application/json");
  reqObj.open('GET', fileName, true);
  reqObj.onreadystatechange = function () {
        if (reqObj.readyState == 4 && reqObj.status == "200") {
          callback(reqObj.responseText);
        }
  };
  reqObj.send(null);
}
\end{lstlisting}

The use of callbacks is standard in Javascript usage on the web, and allowed the code to run in the correct order, i.e. only making the chart once data was loaded in. The call was made as follows

\begin{lstlisting}
loadJSONandMakeChart(chartInfo["fileName"], function(response) {
  var chartData = JSON.parse(response);
  makeChart(chartData, chartInfo, selector);
});
\end{lstlisting}

This provided a small callback to the data loading function, which would load data, use Javascript's standard \texttt{JSON.parse} method to turn the JSON into a Javascript object, and then run a \texttt{makeChart} function once the data was completely loaded and parsed correctly.

This data, along with the chart information that the developer supplied in the function call was then passed to another function to determine the type of chart, and then passed onto the final function to generate the correct type of chart.

\subsection{Interacting with the Webpage}

The \texttt{Document} interface represents a web page in a browser, and is the standard way to query and modify a page's DOM. The method \texttt{document.getElementById} provided a way to get the unique \texttt{Element} object associated with a single HTML element on a web page, specified by a unique \texttt{id} attribute on the element.

% TODO - diagram of HTML document interface

The methods \texttt{document.createElement} and \texttt{document.setAttribute} provided standard way to create new HTML elements and add required attributes onto them.

However, since SVG is part of an XML namespace (as opposed to the pure HTML namespace), it has to be created via an extended function \texttt{document.createElementNS}. The DOM 2 specification (now almost 20 years old) tackled the issue of multiple XML namespaces having identical tags with each other or with HTML, and so the \texttt{createElementNS} method allows the developer to specify the namespace URI for an element.

\begin{lstlisting}
var newSVG=document.createElementNS("http://www.w3.org/2000/svg","svg");
\end{lstlisting}

I also used the corresponding \texttt{document.setAttributeNS} method in my library, as this is a more future-proof way to code and allows consistency between \texttt{setAttribute} calls even if a namespace isn't specified.

The bulk of the graph-making functions were simple translations from the previously-created HTML to creating those elements as HTML elements via Javascript and setting the attributes as required. SVG also has many alignment properties for text that allowed me to position things without using CSS, such as \texttt{text-anchor} and \texttt{dominant-baseline} for the SVG \texttt{<text>} tag.

The information for the ARIA labels was mainly able to be made via looking through the provided data to get properties such as the number of elements, and the smallest and biggest elements. These, combined with the \texttt{"units"} property that the developer put in the method call were used to create labels that read like natural language.

% TODO - some example of the natural language labels?

\subsection{Making Readable Axis}

For the bar and pie charts (but not the line chart) the data needed to be sorted by the value, and so a small helper function handled this.

\begin{lstlisting}
function sortData(array){
  sortedArray = array;

  sortedArray.sort(function(a,b){
    if(a.value == b.value)
        return 0;
    if(a.value > b.value)
        return -1;
    if(a.value < b.value)
        return 1;
  });

  return sortedArray;
}
\end{lstlisting}

When hand-coding the initial graphs I had been able to make axis that provided natural spacing between points (e.g. going up in 5's or 10's) but when creating the library, if the smaller and bigger datapoints weren't rounded like this, then the axis could become awkward and not very readable to the sighted user

% TODO - pic to show awkward axis

To make more readable axis, I also had a helper function to round the last number on the axis to the next relevant power of 10, which would shift the axis to a more natural-looking spacing.

\begin{lstlisting}
function findChartEndNum(dataEndNum){
  lengthofNum = dataEndNum.toString().length;
  divNum = 1;

  if (lengthofNum >= 2){
    divNum = Math.pow(10, (lengthofNum-1))
  }

  endNum = Math.ceil(dataEndNum / divNum) * divNum;
  return endNum;
}
\end{lstlisting}

% TODO - pic of less awkward axis

\subsection{Calculating Trends and Other Mathematics}

For the line graph I wanted to calculate a general trend as part of the overarching graph description, as this is something that a sighted user would be able to tell quickly upon seeing a graph.

In the spirit of not wanting to use any external libraries, I wrote up a

% TODO - finish above
% Algorithm for finding trend for line graph
% viewbox for pie?
% Code for manually generating pie chart

\section{Limitations}

% - Not an effective solution for large data - will become long to read and skip over
% - Readable doesn't mean accessible
% - Hard to make a solution that's accessible for *everyone* - infinite use-cases
% - Some implementation limitations - Arrows keys bit odd - not really a way to define arrow key navigation
% - Library not very customisable at the moment - could do with colours choosing etc.

\chapter{Evaluation}

\section{Study}

\subsection{Study Design}

\subsection{Results}

\subsection{Analysis}

\section{WCAG}

% - WCAG is guidelines
% - Following table shows all criteria being fulfilled

\section{Other?}

% - Things like speed compared to other libraries such as d3

\chapter{Conclusion and Future Work}

% - More customisable library?
% - Expand to more graph types etc.
% - Goals I had for the project, and did I fulfill them (aim for 3/4 goals?)

\chapter{Glossary}

% TODO - add more

When talking about web accessibility, it is useful to highlight some key terms

\BlankLine
%
\glsaddall
\printglossary[nonumberlist]

\printbibliography

\end{document}

%-----------------------------------------------------------------------
% Plan
%-----------------------------------------------------------------------

% WAI-ARIA compliant
% Screen-reader
% Insight on stats?
% Able to tab through (each bar/bubble?)
% Different patterns for colour-blind users
% Stick to few types - bars, pie, line, stacked bars?
% For line talk about trends, for bar/pie talk about most "X is most, do you want to hear more?"
